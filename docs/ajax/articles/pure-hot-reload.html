{
  "title": "Pure Hot Reload",
  "content": "\n\n<div data-section id=\"-pure-hot-reload\">\n<h1>Pure Hot Reload</h1>\n\n<p>2 March 2020</p>\n\n<p>Developing front-end applications requires constant switching between the IDE (or simple text editor) and the browser window. Additionally, when the code is updated, the developer needs to refresh the page which takes a little bit of time. Although this time span can be pretty short (e.g., 1-2 seconds), if the process is repeated over and over again, it adds up to hours in total by the end of the work week (e.g., 2s per refresh &#215; 50  refreshes per hour &#215; 8 hours a day &#215; 5 days = 4000s = 66 min = ~1 hour). It's much better to free up this time and use it more productively, for example, to add a few extra tests or examples in documentation.</p>\n\n<p>\n  <img class=\"ImageHolder b-vk b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"hot reload in javascript\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='2816' height='1880'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"hot_reload/img/hot-reload-splash-1140.webp 1140w,hot_reload/img/hot-reload-splash-768.webp 768w,hot_reload/img/hot-reload-splash-576.webp 576w,hot_reload/img/hot-reload-splash-319.webp 319w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n        type=\"image/webp\">\n      <img class=\"b-vk b-t\" onLoad=\"webploaded(this)\" alt=\"hot reload in javascript\" src=\"hot_reload/img/hot-reload-splash-1140.jpg\" srcset=\"hot_reload/img/hot-reload-splash-1140.jpg 1140w,hot_reload/img/hot-reload-splash-768.jpg 768w,hot_reload/img/hot-reload-splash-576.jpg 576w,hot_reload/img/hot-reload-splash-319.jpg 319w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n    </picture>\n  </noscript>\n</p>\n\n<p>This is why the concept of <strong>hot reload</strong> was invented: to watch changes in the source code, and send the browser a message, that an update is needed. But HR is more than that: it's not just about reloading the window, it's about substituting existing code (functions, classes), for new one SEAMLESSLY for maximum productivity and efficiency. This is not just a \"nice\" feature to have, it's a functional requirement for <em>Preact</em> and <em>React</em> components that can have a STATE: if we just refreshed a component, the state will be lost and we'd have to restart our testing process from the beginning (e.g., select destination from the list, then select a car, to get to the state when the \"continue\" button is showing). Hot reload allows to preserve components' state and helps us develop applications quickly.</p>\n\n<p><em>Idio</em> web server belongs to a new generation of tooling that take the maximum advantage of language features. ES6 standard has been completed in 2015, and everything that we need for web development is available to us already without any need to transpile language features, making such tools as <em>Webpack</em> and <em>Babel</em> redundant for development. And for the build step, our <a href=\"https://www.artd.eco\">Node.JS development company</a> is using <em>Closure Compiler</em>. The requirements are thus to transpile JSX, serve packages as modules, and enable hot reload. All of these features are provided by <em>Idio</em> that aims to implement effective solutions using bare minimum of additional code, and just let browsers do the work. In this article, I'll explain, how <strong>pure</strong> hot reload can work, that is, using JavaScript itself instead of getting vendor-locked into complex packages like <em>Webpack</em>.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/0.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"hmr-101\">\n<h2>HMR 101</h2>\n\n<p>JQuery first appeared in 2006, and JavaScript for the web was quite common of course. But it was in 2012-2015 that the web really underwent its industrial revolution: Flash was being abandoned, multiple Open Source UI frameworks such as <em>React</em> and Vue emerged and started to gain popularity, and build tools began to fill their market niche. It was also time for the hot reload to appear.</p>\n\n<div data-section id=\"react-hot-reload\">\n<h3><em>React</em> Hot Reload</h3>\n\n<!-- I'm not going to go into much detail since I'm not really interested in the past, but prefer to look into the future instead.  -->\n\n<p>I came to know Hot Module Reload like any <em>React</em> developer from documentation in 2017, which by then was pretty stable. But the concept of hot module reload was first discussed by <a href=\"https://www.youtube.com/watch?v=j-kj2qwJa_E\">Bruce Hauman</a> and <a href=\"https://www.youtube.com/watch?v=xsSnOQynTHs\">Dan Abramov</a> back in 2015. At the time, it was a pretty ground-breaking idea, welcomed with enthusiasm by many developers as it's really an essential feature of a development environment that preserves your creativity flow.</p>\n\n<p>\n  <div style=\"position:relative;\" id=\"c3492\">\n    <img class=\"ImageHolder b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,652px\" alt=\"dan abramov talk\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='652' height='362'/%3E\">\n    <noscript>\n      <picture>\n        <source\n          srcset=\"hot_reload/img/dan-576.webp 576w,hot_reload/img/dan-319.webp 319w,hot_reload/img/dan-652.webp 652w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,652px\" type=\"image/webp\">\n        <img class=\"b-t\" onLoad=\"webploaded(this)\" alt=\"dan abramov talk\" src=\"hot_reload/img/dan-576.jpg\" srcset=\"hot_reload/img/dan-576.jpg 576w,hot_reload/img/dan-319.jpg 319w,hot_reload/img/dan-652.jpg 652w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,652px\">\n      </picture>\n    </noscript>\n  </div>\n</p>\n\n<p>Dan's solution is to record methods of a class separately and replace them in instances with proxies. When a change is detected, new methods are sent to the client, and proxies will now execute new code, therefore the actual instance and its state stay untouched. It's about wrapping methods and functions with another meta-function that would be able to perform substitutions at runtime.</p>\n\n<p>To enable the reload for <em>React</em>, we need to import the <span class=\"tm2\">hot</span> method and wrap the default method with it:</p>\n\n<pre id=\"ccdbf\"><code class=\"javascript hljs\">import { Component } from 'react'\nimport { hot } from 'react-hot-loader'\n\nclass App extends Component {\n  render() {}\n}\n\nexport default hot(module)(App)</code></pre>\n\n<p>When calling the <span class=\"tm2\">hot</span> method for the first time, its code will register a proxy for the class.</p>\n\n<pre id=\"ccdbf6\"><code class=\"javascript hljs\">// hot will call:\nreactHotLoader.register(\n  WrappedComponent,\n  getComponentDisplayName(WrappedComponent),\n  'RHL' + moduleId\n);\n\n// register =&gt; createClassProxy =&gt;\n// defineProxyMethods =&gt; fakeBasePrototype =&gt;\n\n/* Each method is going to be wrapped now */\nfunction methodWrapperFactory(wrapperName, realMethod) {\n  return copyMethodDescriptors(function wrappedMethod() {\n    for (var _len2 = arguments.length,\n      rest = Array(_len2),\n      _key2 = 0; _key2 &lt; _len2; _key2++\n    ) {\n      rest[_key2] = arguments[_key2];\n    }\n\n    return realMethod.apply(this, rest);\n  }, realMethod);\n}</code></pre>\n\n<p>A proxy means that methods of the prototype were wrapped by a function that can will call updated methods when they arrive. This is why when you step into an method of a class when hot reload is activated, you'll not get to it straight away, but will end up in the <span class=\"tm\">wrappedMethod</span> instead as shown on the video below.</p>\n\n<div style=\"position:relative;\" id=\"c5c99\">\n  <img class=\"ImageHolder b-t b-vk b-bk b-xq\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"using the debugger\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='914' height='346'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"hot_reload/2-history/img/devtools-768.webp 768w,hot_reload/2-history/img/devtools-576.webp 576w,hot_reload/2-history/img/devtools-319.webp 319w,hot_reload/2-history/img/devtools-914.webp 914w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n        type=\"image/webp\">\n      <img class=\"b-t b-vk b-bk b-xq\" onLoad=\"webploaded(this)\" alt=\"using the debugger\" src=\"hot_reload/2-history/img/devtools-768.jpg\" srcset=\"hot_reload/2-history/img/devtools-768.jpg 768w,hot_reload/2-history/img/devtools-576.jpg 576w,hot_reload/2-history/img/devtools-319.jpg 319w,hot_reload/2-history/img/devtools-914.jpg 914w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n    </picture>\n  </noscript>\n</div>\n\n<p>The wrapper and other features make up <a href=\"https://github.com/gaearon/react-hot-loader/\"><span class=\"tm\">react-hot-loader</span></a> while it's <em>Webpack</em> that is responsible for establishing client-server communication and providing an API for updates of MODULES (everything that's exported), but not classes (refreshes to which are more refined by <em>React</em>'s hot loader).</p>\n\n<!-- end react -->\n</div>\n\n<div data-section id=\"webpack-modules\">\n<h3><em>Webpack</em> Modules</h3>\n\n<p>Whereas the <span class=\"tm\">react-hot-loader</span> can be seen as \"software\" reloading mechanism, the modular system of <em>Webpack</em> can then be thought of as underlying \"hardware\". Its internal logic is very easy to understand<span id=\"c06ef\"></span> NOT!</p>\n\n<p class=\"b-kC\">\n  <img class=\"ImageHolder b-vk b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,667px\" alt=\"depack modular system\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='667' height='374'/%3E\">\n  <noscript>\n    <picture>\n      <source srcset=\"\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,667px\"\n        type=\"image/webp\">\n      <img class=\"b-vk b-t\" onLoad=\"webploaded(this)\" alt=\"depack modular system\" src=\"hot_reload/img/webpack-576.png\" srcset=\"hot_reload/img/webpack-576.png 576w,hot_reload/img/webpack-319.png 319w,hot_reload/img/webpack-667.png 667w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,667px\">\n    </picture>\n  </noscript>\n  <br><span class=\"b-dC\">&copy; <a href=\"http://docplayer.net/94651783-How-works-tobias-koppers.html\">Tobias Koppers</a></span>\n</p>\n\n<p>What you see is a complex build tool that implements its own modular system. In short, it analyses source code, builds dependency trees, and puts everything together (it can also tree-shake unused code). It will always wrap source code into its own, making it a black box for everyone who doesn't get hands on its internals. The total code can then be served to the browser in chunks, but it's all tied up to <em>Webpack</em>'s own modules.</p>\n\n<pre id=\"ccdbf1\"><code class=\"javascript hljs\">/* index.js */\nconst a = lib()\n\n// becomes:\nconst a = Object(_lib__WEBPACK_IMPORTED_MODULE_3__[\"lib\"])();\n\n/* lib.js */\nexport const lib = () =&gt; {\n  console.log('lib')\n}\n\n// becomes\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lib\", function() { return lib; });\nconst lib = () =&gt; {\n  return 'example';\n};</code></pre>\n\n<p>Both files are concatenated into a single chunk. The code above shows that the lynchpin of <em>Webpack</em> is <span class=\"tm\">__webpack_require__</span> that ties together all modules in the whole of the bundle. It's quite similar to browserify that also makes use of CommonJS require method (via its <a href=\"https://github.com/browserify/browser-pack/blob/master/prelude.js\"><span class=\"tm2\">prelude</span></a>) to make dependencies aware of each other.</p>\n\n<p>But then again, when you debug, to step in an exported function from a module, you will have to make 4 clicks instead of 1:</p>\n\n<ul>\n  <li>step in webpack module getter (4)</li>\n  <li>step in return from module getter (3)</li>\n  <li>step in object wrapper (2)</li>\n  <li><strong>land in function call</strong> (1)</li>\n</ul>\n\n<p>Your debugging experience is weak and you have to set breakpoints manually in your functions, in order to step into them without this inconvenience. When source maps are <strong>enabled</strong>, you will be landing on random places in code like so:</p>\n\n<p>\n  <div style=\"position:relative;\" id=\"cd409\">\n    <img class=\"ImageHolder b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"debugging with source maps\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='980' height='514'/%3E\">\n    <noscript>\n      <picture>\n        <source\n          srcset=\"hot_reload/2-history/wysywyg/png/b--768.webp 768w,hot_reload/2-history/wysywyg/png/b--576.webp 576w,hot_reload/2-history/wysywyg/png/b--319.webp 319w,hot_reload/2-history/wysywyg/png/b--980.webp 980w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n          type=\"image/webp\">\n        <img class=\"b-t\" onLoad=\"webploaded(this)\" alt=\"debugging with source maps\" src=\"hot_reload/2-history/wysywyg/png/b--768.png\" srcset=\"hot_reload/2-history/wysywyg/png/b--768.png 768w,hot_reload/2-history/wysywyg/png/b--576.png 576w,hot_reload/2-history/wysywyg/png/b--319.png 319w,hot_reload/2-history/wysywyg/png/b--980.png 980w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n      </picture>\n    </noscript>\n  </div>\n</p>\n\n<p>To understand what's going on behind the scenes, we have to disable source maps, and check where we're really in the program. As I described above, your import will be wrapped in a getter of <em>Webpack</em>'s module system, which in turn will be wrapped in an <span class=\"tm\">Object</span> converter.</p>\n\n<p>\n  <div style=\"position:relative;\" id=\"c2ed2\">\n    <img class=\"ImageHolder b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"debugging without source maps\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='980' height='514'/%3E\">\n    <noscript>\n      <picture>\n        <source\n          srcset=\"hot_reload/2-history/wysywyg/png/a--768.webp 768w,hot_reload/2-history/wysywyg/png/a--576.webp 576w,hot_reload/2-history/wysywyg/png/a--319.webp 319w,hot_reload/2-history/wysywyg/png/a--980.webp 980w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n          type=\"image/webp\">\n        <img class=\"b-t\" onLoad=\"webploaded(this)\" alt=\"debugging without source maps\" src=\"hot_reload/2-history/wysywyg/png/a--768.png\" srcset=\"hot_reload/2-history/wysywyg/png/a--768.png 768w,hot_reload/2-history/wysywyg/png/a--576.png 576w,hot_reload/2-history/wysywyg/png/a--319.png 319w,hot_reload/2-history/wysywyg/png/a--980.png 980w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n      </picture>\n    </noscript>\n  </div>\n</p>\n\n<p>So not only <em>Webpack</em> is bulky, but it also is directly going against our developer experience. Those seconds we might have saved on hot-reload, we're now loosing when debugging our front-end applications.</p>\n\n<!-- <table class=\"b-ze\">\n  <thead>\n    <tr>\n      <th scope=\"col\">What You See (w/ sourcemaps)</th>\n      <th scope=\"col\">What You Get (w/out sourcemaps)</th>\n    </tr>\n  </thead>\n</table>\n\n<div class=\"b-B\">\n  <div class=\"b-J\">\n    <img class=\"b-t\" webp=\"text\" src=\"/wysywyg/png/b.png\" alt=\"with sourcemap step 1\">\n  </div>\n  <div class=\"b-J\">\n    <img class=\"b-t\" webp=\"text\" src=\"/wysywyg/png/a-.png\" alt=\"without sourcemap step 1\">\n  </div>\n</div> -->\n\n<!-- end webpack -->\n</div>\n\n<div data-section id=\"price-of-stack\">\n<h3>Price of Stack</h3>\n\n<p>From this quick research we're drawing a conclusion that our web interfaces today are based on a build platform, such as <em>Webpack</em>, and on a framework, such as <em>React</em>. Both of them imply their additional cost: in terms of dependencies, and complexity introduced into the system (e.g., clicking 3 times to step into a function).</p>\n\n<p>We've looked at the complexity derived from an implementation of the modules' wireframe, so let's quickly discuss the technical cost in terms of 3rd party dependencies. <em>Webpack</em> has become pretty much a default for front-end web-development, but did you know that you're pulling along 342 additional dependencies during its installation:</p>\n\n<p class=\"b-kC\">\n  <img class=\"b-vk b-t\" alt=\"webpack dependencies graph\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='864' height='484'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-vk b-t\" alt=\"webpack dependencies graph\" src=\"hot_reload/img/webpack.jpg\">\n  </noscript>\n</p>\n\n<p>Your <span class=\"tm2\">node_modules</span> will be 20MB after that, but it seems like nobody cares about that sort of thing anymore. Everyone is so used to this sad reality of life, that it just became normal. <em>Webpack</em> is probably OK for larger projects but if you want to create a very simple JS app, you basically need a nuclear power plant, and this is repeated for each new project. <em>Webpack</em> is good software that has helped to put together many websites, but it doesn't have to be a standard, and many people have been experimenting with other bundlers like Rollup, <em>Parcel</em>, and <em>Closure Compiler</em>.</p>\n\n<!-- I'm not very happy with jamming my <span class=\"tm\">node_modules</span> so that I can produce a bundle, are you? -->\n\n<!-- This is absolute madness. This is what I hate about modern Node.JS state-of-art, it's completely bonkers. It's not acceptable and all these dependencies would repulse any sane developer, had the community not been beaten into submission by current industry leaders, and developers have nothing left but to quietly obey and keep installing <em>Webpacks</em> and <em>Babels</em>. <strong>Idio</strong> is finally here to fix this and put open source right. I'm going to liberate you from this hell. -->\n\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/1.svg\"></noscript></a>\n</p>\n</div>\n\n\n<!-- ##! New Vendor Lock -->\n\n<!-- Open Source supposedly saves us from \"vendor lock\" &mdash; but does it really? Instead of corporate vendor lock into proprietary software, we now have... Open Source vendor lock into popular projects like WebPack. Most of the build pipelines are based on WebPack, Rollup and <em>Babel</em>. And to tell you the truth: Open Source vendor lock is even worse than corporate one, because it's popular Open Source developers of those projects who now think they're the rules of the world with all that popularity hitting their heads, while you're not allowed to raise any complaints about their software, because they're apparently volunteers providing software to you for free. -->\n\n<!-- <p class=\"b-bk b-vk b-br b-jC\" style=\"box-shadow: 0 3px 11px 5px lightsteelblue;\">\n  <img class=\"ImageHolder b-t\" sizes=\"(max-width: 575.8px) 100vw,440px\" alt=\"free software\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='440' height='74'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"hot_reload/img/free-319.webp 319w,hot_reload/img/free-440.webp 440w\" sizes=\"(max-width: 575.8px) 100vw,440px\" type=\"image/webp\">\n      <img class=\"b-t\" onLoad=\"webploaded(this)\" alt=\"free software\" src=\"hot_reload/img/free-319.png\" srcset=\"hot_reload/img/free-319.png 319w,hot_reload/img/free-440.png 440w\" sizes=\"(max-width: 575.8px) 100vw,440px\">\n    </picture>\n  </noscript>\n  <br><span class=\"b-dC\">^ In Open Source, you owe your life and business to maintainers for using their \"free\" software. It's a disgrace what this bunch have turned Open Source into.</span>\n</p> -->\n\n<!-- The situation is extremely hostile against people like myself who raise questions and doubts about where we're going, indicating the decadence of the scene and clinging to the power by those \"leaders\". No free speech is allowed that doesn't suit the newly established \"elite\". This article will never appear on any newsletter because they're afraid to face the truth. But don't worry about them &mdash; in 2020, we can move on to the new age tools that provide completely transparent experience, while treating YOU with respect, so that you can expect to be a VALUABLE and LOVED user, and not hostage to somebody's technology. -->\n\n<!-- <section-break /> -->\n\n<div data-section id=\"new-age-solutions\">\n<h2>New Age Solutions</h2>\n\n<p>Open Source supposedly saves us from \"vendor lock\" &mdash; but does it really? Instead of corporate vendor lock into proprietary software, we now have<span id=\"c06ef1\"></span> Open Source vendor lock into popular projects like <em>Webpack</em>. This is because the web was still maturing in the last 5 years.\n</p>\n\n<div data-section id=\"from-user-to-developer\">\n<h3>From User To Developer</h3>\n\n<p>However, now we can explore another way: in 2020, we're moving on to new age tools that provide completely transparent experience, thanks to the adoption of modules by browsers. They will allow you to stop being a USER of 3rd party technology, and remain a DEVELOPER who takes her profession in hand.</p>\n\n<p>Today, web developers can finally focus on utilising language and worry less about bundling. We still need to build for older browsers which is fine, but development process can go directly through  the browser, bypassing custom modular systems of build tools that were required before browsers supported modules. This is how nice and important ES6 is, benefits of which we are ripping today.</p>\n\n<h4 id=\"which-one-are-you\">Which One Are You?</h4>\n\n<div class=\"b-B b-xq b-kr\" style=\"border-bottom: .5rem dotted #dbc3c0;\">\n  <div class=\"b-kC b-D\">\n    <img class=\"ImageHolder b-vk b-Ik b-xq b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 510px,(max-width: 1199.8px) 690px,825px\" alt=\"user of software\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1000' height='667'/%3E\">\n    <noscript>\n      <picture>\n        <source\n          srcset=\"hot_reload/4-new-age/img/user-768.webp 768w,hot_reload/4-new-age/img/user-576.webp 576w,hot_reload/4-new-age/img/user-319.webp 319w,hot_reload/4-new-age/img/user-1000.webp 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 510px,(max-width: 1199.8px) 690px,825px\"\n          type=\"image/webp\">\n        <img class=\"b-vk b-Ik b-xq b-t\" onLoad=\"webploaded(this)\" alt=\"user of software\" src=\"hot_reload/4-new-age/img/user-768.jpg\" srcset=\"hot_reload/4-new-age/img/user-768.jpg 768w,hot_reload/4-new-age/img/user-576.jpg 576w,hot_reload/4-new-age/img/user-319.jpg 319w,hot_reload/4-new-age/img/user-1000.jpg 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 510px,(max-width: 1199.8px) 690px,825px\">\n      </picture>\n    </noscript>\n    <span>\n      <button class=\"UDB b-Af b-Kf\">I'm a user!</button>\n      <span style=\"display:none;\">You give developers something to do! Preorder <a href=\"https://artdeco.tech/book\">Art Deco JavaScript</a> to learn easy professional JS coding to become a developer yourself.</span>\n    </span>\n  </div>\n  <div class=\"b-kC b-D\">\n    <img class=\"ImageHolder b-vk b-Ik b-xq b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 510px,(max-width: 1199.8px) 690px,825px\" alt=\"developer of software\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1000' height='667'/%3E\">\n    <noscript>\n      <picture>\n        <source\n          srcset=\"hot_reload/4-new-age/img/developer-768.webp 768w,hot_reload/4-new-age/img/developer-576.webp 576w,hot_reload/4-new-age/img/developer-319.webp 319w,hot_reload/4-new-age/img/developer-1000.webp 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 510px,(max-width: 1199.8px) 690px,825px\"\n          type=\"image/webp\">\n        <img class=\"b-vk b-Ik b-xq b-t\" onLoad=\"webploaded(this)\" alt=\"developer of software\" src=\"hot_reload/4-new-age/img/developer-768.jpg\" srcset=\"hot_reload/4-new-age/img/developer-768.jpg 768w,hot_reload/4-new-age/img/developer-576.jpg 576w,hot_reload/4-new-age/img/developer-319.jpg 319w,hot_reload/4-new-age/img/developer-1000.jpg 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 510px,(max-width: 1199.8px) 690px,825px\">\n      </picture>\n    </noscript>\n    <span>\n      <button class=\"UDB b-Af b-If\">I'm a developer!</button>\n      <span style=\"display:none;\">The internet is made by people like you. Why not try <a href=\"https://artdeco.tech/alibaba\">Alibaba Cloud Hosting</a> and receive a 1GB instance free for 12 months? + complimentary <span class=\"b-Oh b-Sh\">.tech</span> domain!</span>\n    </span>\n  </div>\n</div>\n\n<!-- Most of the build pipelines are based on <em>Webpack</em>, <em>Rollup</em> and <em>Babel</em>. And to tell you the truth: Open Source vendor lock is even worse than corporate one, because those who run such popular Open Source projects don't accept any criticism as they think that because they are volunteers, you don't have any rights as a user. -->\n\n<!-- <p class=\"b-bk b-vk b-br b-jC\" style=\"box-shadow: 0 3px 11px 5px lightsteelblue;\">\n  <img class=\"b-t\" webp=\"text\" src=\"/img/free.png\" alt=\"free software\">\n  <br><span class=\"b-dC\">^ In Open Source, you owe your life and business to maintainers for using their \"free\" software. It's a disgrace what the scene has been turned into.</span>\n</p> -->\n\n<!-- You're now vendor locked, AND you can't ever express your dissatisfaction with something. And actually why do we have to use software like <em>Babel</em> and <em>Webpack</em> &mdash; because it's good, or because we had no choice?  -->\n\n<!-- so that you can expect to be a VALUED and LOVED user, and not hostage to somebody's technology. -->\n\n<!-- because it's popular Open Source developers of those projects who now think they're the rules of the world with all that popularity hitting their heads, while you're not allowed to raise any complaints about their software, because they're apparently volunteers providing software to you for free. -->\n\n<!-- It's true that <em>Webpack</em> as a build tool was needed during the last 5 years. It has got nice features like code splitting. But the room for dev utils that take advantage of present-day opportunities is being filled by more nimble software.  -->\n\n<p>Although we've been talking about build tools up to this point, I'd like you to switch off thinking in terms of the platform they provide from now on: with <em>new age</em> in mind, we always focus on the <strong>principle</strong> and not technology.</p>\n\n</div>\n\n<div data-section id=\"frictionless-development\">\n<h3>Frictionless Development</h3>\n\n<p>To explore the principle behind frictionless front-end development, let me introduce <em>Idio</em>. <em>Idio</em> is a <a href=\"/\">professional web server</a> which has been compiled with <em>Closure</em>, and has only 2 dependencies. It consists of ES6-rewritten <em>Koa</em> with a collection of middleware, but it also allows to develop JavaScript for the browser. To enable the web development process, it ships with our in-house <strong>FrontEnd</strong> middleware &mdash; one of the modules-era nimble tools that does the following:</p>\n\n<h4 id=\"1-you-specify-the-directory-with-your-frontend-code-eg--innercode-10-\">\n  1. You specify the directory with your frontend code, e.g., <span class=\"tm\">frontend</span>.\n</h4>\n\n<p>For example, you can have the following source in <span class=\"tm2\">frontend/index.js</span>:</p>\n\n<pre id=\"ccdbf2\"><code class=\"javascript hljs\">import { dep } from 'my-dep'\nimport local from './local'\n\nconst el = document.querySelector('#id')\ndep(el) // execute dependency\nlocal(el) // execute local</code></pre>\n\n<p>When the browser requests this JS module via a script tag, <span class=\"tm\">&lt;script type=&quot;module&quot; src=&quot;frontend&quot;&gt;&lt;/script&gt;</span>, <strong>FrontEnd</strong> will intersect the request, and lookup <span class=\"tm\">my-dep</span> in your <span class=\"tm2\">node_modules</span>, to find its <em>package.json</em>. From there, the <strong>module</strong> field will be read, and the served file will actually contain absolute paths required by the browser. Local dependencies can also be served, which would be impossible under normal circumstances when the extension (<span class=\"tm\">.js</span>) is not present, but the middleware can handle that.</p>\n\n<pre id=\"ccdbf3\"><code class=\"javascript hljs\">import { dep } from '/node_modules/my-dep/src/index.js'\nimport local from './local'\n\nconst el = document.querySelector('#id')\ndep(el) // execute dependency\nlocal(el) // execute local</code></pre>\n\n<p>Now the browser can import the dependency natively. The middleware will return any JS file under the <span class=\"tm2\">/node_module</span> path, enabling direct dependency serving, without having to wrap anything in vendor modular system. This simple step drastically reduces the complexity of the tool-chain, as it's the browser that's doing most of the work from this point onwards. On-the-fly modifications of paths are made with the simplest RegEx that picks up <span class=\"tm\">import</span> statements.</p>\n\n<h4 id=\"2-you-write-jsx-code-in-your-frontend\">2. You write JSX code in your frontend.</h4>\n\n<p>JSX is positively THE BEST templating syntax for web development, and there's no doubt about that. Although it was initially developed by <em>React</em>, its roots actually go much deeper than that, as MXML (Flash applications) used to have similar structure.</p>\n\n<p>\n  <img class=\"ImageHolder b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,620px\" alt=\"flex data bindings\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='620' height='238'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"hot_reload/4-new-age/img/mxml-576.webp 576w,hot_reload/4-new-age/img/mxml-319.webp 319w,hot_reload/4-new-age/img/mxml-620.webp 620w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,620px\" type=\"image/webp\">\n      <img class=\"b-t\" onLoad=\"webploaded(this)\" alt=\"flex data bindings\" src=\"hot_reload/4-new-age/img/mxml-576.png\" srcset=\"hot_reload/4-new-age/img/mxml-576.png 576w,hot_reload/4-new-age/img/mxml-319.png 319w,hot_reload/4-new-age/img/mxml-620.png 620w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,620px\">\n    </picture>\n  </noscript>\n  <br><span class=\"b-dC\"> &copy; <a\n  href=\"https://www.jeffryhouser.com/index.cfm/2012/1/3/Moving-your-Flex-Components-from-MXML-to-ActionScript-3\">\n  Jeffry Houser</a> 2012</span>\n</p>\n\n<p>JSX is a revival of MXML and an essential part of programming of the web. There's an interesting alternative to JSX called <span class=\"tm\">lit-html</span> but it makes no sense why I should use template literals when writing tags. It's simply a hack to eliminate JSX transpilation, but it's not a replacement for JSX, which is the daddy of modern web computing.</p>\n\n<pre id=\"ccdbf7\"><code class=\"javascript hljs\">// JSX\nimport { render, Component } from 'preact'\n\nclass App extends Component {\n  constructor() {\n    super()\n    this.state = { name: 'world' }\n  }\n  render({ message }) {\n    return (&lt;div&gt;\n      Hello, &lt;span&gt;{this.state.name}&lt;/span&gt;\n      &lt;p&gt;\n        {message}\n      &lt;/p&gt;\n    &lt;/div&gt;)\n  }\n}\n\nrender(&lt;App message=\"Idio\"/&gt;, document.querySelector('.app'))</code></pre>\n\n<p>An example of using lit html is the following:</p>\n\n<pre id=\"ccdbf8\"><code class=\"javascript hljs\">import { define, html } from 'https://unpkg.com/hybrids@4.1.3/src/index.js'\n\nconst HybridsApp = {\n  appName: 'Welcome to Hybrids!',\n\n  pageLoaded: '&lt;span&gt;No page loaded, yet.&lt;/span&gt;',\n\n  page: ({ pageLoaded }) =&gt; pageLoaded,\n\n  render: ({ appName, page }) =&gt;\n    html`\n      &lt;div&gt;\n        &lt;h1&gt;${appName}&lt;/h1&gt;\n        &lt;p&gt;Example of an unbundled Hybrids app with dynamic imports.&lt;/p&gt;\n        &lt;div&gt;\n          &lt;button onclick=\"${load}\" page=\"./pages/Welcome.mjs\"&gt;\n            Welcome Page\n          &lt;/button&gt;\n          &lt;button onclick=\"${load}\" page=\"./pages/Other.mjs\"&gt;\n            Other Page\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `,\n}</code></pre>\n\n<p><span class=\"b-dC\">&copy; F1LT3R 2020, <a href=\"https://github.com/F1LT3R/hybrids-dynamic-load\"><span class=\"tm\">hybrids-dynamic-load</span></a>.</span></p>\n\n<p>The advantage of this over JSX is that it doesn't require transpilation and can be run natively within a browser. The disadvantage is that there's no syntax highlighting (unless you use a plugin) and it's not as fluent as JSX that doesn't require calling <span class=\"tm\">html</span> function to start a template block.</p>\n\n<p>You might be thinking that to transpile JSX you need <em>Babel</em>, but the fact is that you don't. You don't need to build ASTs and you don't need to install additional 250 dependencies that come with <em>Babel</em>, another \"established\" standard of coding. <strong>FrontEnd</strong> uses a <a href=\"https://github.com/a-la/jsx\">JSX transpiler</a> powered by regular expressions. It includes a hack to find where the initial tag (<span class=\"tm2\">&lt;</span>) is opening by evaluating the jsx file using the <span class=\"tm\">vm</span> module of Node.JS. The tag is detected by listening to an error:</p>\n\n<pre id=\"ccdbf4\"><code class=\"javascript hljs\">/Users/zavr/a-la/jsx/test/fixture/Component.jsx:2\n  &lt;div className={className}&gt;\n  ^\n\nSyntaxError: Unexpected token &lt;</code></pre>\n\n<p>This evaluation is needed to prevent false positives, e.g., <span class=\"tm\">if (a&lt;example &amp;&amp; b)</span>. After detecting the location of the angle bracket, we are able to parse text, until the closing tag is found, unless it was self-closing. Properties are also extracted using regular expressions on strings. Now look, you can think that it's very simplistic, but this stuff works and works really well. It supports comments and pretty much everything you want from JSX, except that you can't use <span class=\"tm\">&gt;</span> in properties, e.g.,</p>\n\n<pre id=\"ccdbf9\"><code class=\"javascript hljs\">const Next = () =&gt; (&lt;a href=\"#\"&gt;Next Page&lt;/a&gt;)\n\nconst Component = ({ data = [] }) =&gt; {\n  return (&lt;div&gt; {\n    data.map((i, j) =&gt; {\n      if (j &gt; 10) return &lt;Next /&gt;\n      return i\n    })\n  }\n  &lt;/div&gt;)\n}</code></pre>\n\n<p>But methods like that simply need to be taken out of the tag scope. You're probably not going to replace <em>Webpack</em> with <em>Idio</em> at your corporate insurer job, but if you're working for fun projects, there's no reason why you can't be using this. Except for that there's no source maps, which will be added later on this year, but because the code produced looks absolutely natural, it's easy to debug it anyway (unless you've got the super-power setup where your VS Code debugger hooks up to a running Chrome RDP process).</p>\n\n<pre id=\"ccdbf5\"><code class=\"javascript hljs\">// JSX - compiled code\nimport { render, Component } from 'preact'\n\nclass App extends Component {\n  constructor() {\n    super()\n    this.state = { name: 'world' }\n  }\n  render({ message }) {\n    return (h('div',{},\n      `Hello, `,h('span',{},this.state.name),\n      h('p',{},\n        message,\n      ),\n    ))\n  }\n}\n\nrender(h(App,{message:\"Idio\"}), document.querySelector('.app'))</code></pre>\n\n<p>I've created many <a href=\"https://akashic.page\">widgets</a>, <a href=\"https://github.com/art-deco/file-upload.artdeco.app\">front-end apps</a> and back-end servers with SSR powered by this transpiler. There hasn't been any problems. Maybe it will throw errors on some very advanced edge use cases (never happened for me, although your usage might be something I've never tested), but simplifying code will always help. Its simplicity is the key.</p>\n\n<p>In short, with the <strong>FrontEnd</strong> middleware from <em>Idio</em>, I was able to bypass the build step for development stage, which is the most prevalent one in any web UI life cycle. By testing modern code right in a modern browser, I can reduce the friction between my actual ES6 modules (which actually have been a standard since 2015), and the browser. Transforms on JSX are done real-time but don't introduce any additional modular complexity.</p>\n\n</div>\n\n<div data-section id=\"developer-freedom\">\n<h3>Developer Freedom</h3>\n\n<p>Personally, I really wanted to breath freely when working on each new project, and not be brought down by the anxiety that filled me up when:</p>\n\n<ul>\n  <li>MY <span class=\"tm2\">node_modules</span> were being taken over;</li>\n  <li>MY code was wrapped in somebody else's system; and</li>\n  <li>I lost all control.</li>\n</ul>\n\n<p>There's no happier place than to be able to direct the development process yourself, being able to say, \"I'm the boss here, not you, dependencies and bundlers!\".</p>\n\n<p>\n  <img class=\"ImageHolder b-vk b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"control photo with birds\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='2816' height='1880'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"hot_reload/4-new-age/img/control2-1140.webp 1140w,hot_reload/4-new-age/img/control2-768.webp 768w,hot_reload/4-new-age/img/control2-576.webp 576w,hot_reload/4-new-age/img/control2-319.webp 319w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n        type=\"image/webp\">\n      <img class=\"b-vk b-t\" onLoad=\"webploaded(this)\" alt=\"control photo with birds\" src=\"hot_reload/4-new-age/img/control2-1140.jpg\" srcset=\"hot_reload/4-new-age/img/control2-1140.jpg 1140w,hot_reload/4-new-age/img/control2-768.jpg 768w,hot_reload/4-new-age/img/control2-576.jpg 576w,hot_reload/4-new-age/img/control2-319.jpg 319w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n    </picture>\n  </noscript>\n</p>\n\n<p>The <strong>FrontEnd</strong> solution might not be approved in corporate &mdash; which only confirms the fact they've been locked into their \"Open Source\" software, but for JS enthusiasts and hackers, it's perfect. I'm not offering an alternative that you'll be stuck with: you can see that developing front-end is really easy in 2020, as all you need is to serve JavaScript modules with a few on-the-fly modifications. I've not invented a new system, I've only patched up those things that were missing:</p>\n\n<ol>\n  <li>rename imported package names into paths: <span class=\"tm2\">'dep'</span> -> <span class=\"tm\">'/node_modules/dep/src/module.js'</span>;</li>\n  <li>serve packages and other JS files even without extensions (<span class=\"tm\">'./lib'</span>);</li>\n  <li>transpile JSX on the fly via an MVP transpiler;</li>\n  <li>[read below] implement hot reload for ES6 exports.</li>\n</ol>\n\n<!-- After being liberated from the shackles of dependencies, I could finally focus on writing source code to build more software products for my company. But most of all, I've gained independence. -->\n\n<div class=\"b-xq\">\n  <div class=\"b-tp\" id=\"c259c\">\n    <img class=\"b-t\" alt=\"frontend middleware\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='622' height='256'/%3E\" data-io>\n    <noscript>\n      <img class=\"b-t\" alt=\"frontend middleware\" src=\"hot_reload/4-new-age/img/frontend.png\">\n    </noscript>\n  </div>\n</div>\n\n<p>These 4 things enable clean development environment with minimum technical debt. With browsers supporting modules, we can leave build tools for building, but develop code natively. All features that we might want are implemented by Chrome and iOS Safari for us to test &mdash; happy days. It's true that we'll also need to combine our frontend code into a bundle, but we'll discuss the build step at the end. For now, let's have a look at hot reload, the final requirement for the front-end and its simplest form of implementation.</p>\n\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/2.svg\"></noscript></a>\n</p>\n</div>",
  "file": "./hot_reload",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}