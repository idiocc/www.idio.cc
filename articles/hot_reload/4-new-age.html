##! New Age Solutions

Even if Webpack was needed during the last 5 years, it's almost entirely served its purpose, and the room for dev utils that exploit present-day opportunities is being filled by more nimble software. Idio is a professional server which has been compiled with Closure, and has only 2 dependencies. It consists of ES6-rewritten Koa with a collection of middleware, but it also allows to develop JavaScript for the browser. To enable web development process, it ships with our in-house *Front End* middleware, that does the following:

### 1. You specify the directory with your frontend code, e.g., `frontend`.

For example, you can have the following source:

```js
import { dep } from 'my-dep'
import local from './local'

const el = document.querySelector('#id')
dep(el) // execute dependency
local(el) // execute local
```

When the browser requests this JS module, *FrontEnd* will intersect the request, and lookup `my-dep` in your ``node_modules``, to find its package.json. From there, the module field will be read, and the served file will actually contain absolute paths required by the browser. Local dependencies can also be served, which isn't impossible under normal circumstances when the extension (`.js`) is not present, but the middleware can handle that.

```js
import { dep } from '/node_modules/my-dep/src/index.js'
import local from './local'

const el = document.querySelector('#id')
dep(el) // execute dependency
local(el) // execute local
```

Now the browser can import the dependency natively. The middleware will serve any JS files under the ``/node_module`` path, enabling direct dependency serving, without having to wrap anything in vendor modular system. This simple step drastically reduces the complexity of the toolchain, as it's the browser that's doing most of the work from this point onwards. Live modifications are made with the simplest RegEx that picks up `import` statements.

### 2. You write JSX code in your frontend.

JSX is positively THE BEST templating syntax for web development, and there's no doubt about that. Although it was initially developed by _React_, its roots actually go much deeper than that, as MXML (Flash applications) used to have similar structure.

<p>
  <img img-fluid webp="text" src="./img/binding.jpg" alt="flex bindings" />
  <br><span text-monospace> &copy; [Elad Elrom, Adobe](https://www.adobe.com/devnet/flex/articles/databinding_pitfalls.html) 2010</span>
</p>

JSX is a revival of MXML and an essential part of programming of the web. There's a parody of JSX called `lit-html` but it makes no sense why I should use template literals when writing tags. It's simply a hack to eliminate JSX transpilation, but it's not a replacement for JSX, which is the daddy of modern web computing.

<highlightjs src="./example/App.mjs"/>

An example of using lit html is the following:

<highlightjs src="./example/lit.mjs"/>

<p><span text-monospace>&copy; F1LT3R 2020, [`hybrids-dynamic-load`](https://github.com/F1LT3R/hybrids-dynamic-load).</span></p>

The advantage of this over JSX is that it doesn't require transpilation and can be run natively within a browser. The disadvantage is that there's no syntax highlighting (unless you use a plugin) and it's not as fluent as JSX that doesn't require calling `html` function to start a template block.

You might be thinking that to transpile JSX you need Babel, but the fact is that you don't. You don't need to build ASTs and you don't need to install additional 250 dependencies that come with Babel, another "established" standard of coding. *FrontEnd* uses a [JSX transpiler](https://github.com/a-la/jsx) that uses regular expressions. It includes a hack to find where the initial tag (``<``) is opening by evaluating the jsx file using the `vm` module of Node.JS. The tag is detected by listening to an error:

```jsx
/Users/zavr/a-la/jsx/test/fixture/Component.jsx:2
  <div className={className}>
  ^

SyntaxError: Unexpected token <
```

From then on, we are able to parse text, until the closing tag is found, unless it was self-closing. Properties are also extracted using regular expressions on strings. Now look, you can think that it's very simplistic, but this stuff works and works really well. It supports comments and pretty much everything you want from JSX, except that you can't use `>` in properties, e.g.,

<highlightjs src="./example/Component.mjs" lang="jsx"/>

But methods like that simply need to be taken out of the tag scope. You're probably not going to replace _Webpack_ with Idio at your corporate insurer job, but if you're working for fun projects, there's no reason why you can't be using this. Except for that there's no source maps, which will be added later on this year, but because the code produced looks absolutely natural, it's easy to debug it anyway.

```js
// JSX - compiled code
import { render, Component } from 'preact'

class App extends Component {
  constructor() {
    super()
    this.state = { name: 'world' }
  }
  render({ message }) {
    return (h('div',{},
      `Hello, `,h('span',{},this.state.name),
      h('p',{},
        message,
      ),
    ))
  }
}

render(h(App,{message:"Idio"}), document.querySelector('.app'))
```

I've created many [widgets](https://akashic.page), [front-end apps](https://github.com/art-deco/file-upload.artdeco.app) and back-end servers with SSR powered by this transpiler. There hasn't been any problems. Maybe it will throw errors on some very advanced edge use cases (never happened for me, although your usage might be something I've never tested), but simplifying code will always help. Its simplicity is the key.

<p>
  <img rounded img-fluid src="./img/control.jpg" webp="photo" alt="control photo with birds" />
</p>

As an indie web developer, I was looking to fulfil the need to create JS applications for the web without anything getting in the way. I wanted to breath freely when working on each new project, and not be brought down by the anxiety that filled me up when my ``node_modules`` were being taken over and I lost all control. There's no happier place than to be able to direct the development process, saying, "I'm the boss here, not dependencies!".

The *FrontEnd* solution might not be approved in corporate &mdash; which only proves they've been locked into other "Open Source" software, but for JS enthusiasts and hackers, it's perfect. After being liberated from the shackles of dependencies, I could finally focus on writing source code to build more software products for my company. Bust most of, I've gained independence. I'm not offering you an alternative that you'll be stuck with instead: instead, you can see that developing front-end is really easy in 2020, as all you need is JavaScript modules. We'll discuss the build step in the end. For now, let's look at hot reload, the final requirement for the front-end and its simplest implementation.

<section-break />