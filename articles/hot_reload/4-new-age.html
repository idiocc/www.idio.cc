##! New Age Solutions

Open Source supposedly saves us from "vendor lock" &mdash; but does it really? Instead of corporate vendor lock into proprietary software, we now have<ellipsis/> Open Source vendor lock into popular projects like Webpack. This is because the web was still maturing in the last 5 years.

However now we can explore another way: in 2020, we can move on to the new age tools that provide completely transparent experience, thanks to the adoption of modules by browsers. They will allow you to stop being a USER of 3rd party technology, and remain a DEVELOPER who takes her profession in hand. Today web developers can finally focus on utilising language and worry less about bundling. We still need to build for older browsers which is fine, but development process can go directly through  the browser, bypassing custom modular systems of build tools that were required before browsers supported modules. This is how nice and important ES6 is, benefits of which we are ripping today.

### Which One Are You?

<row mb-3 py-3 border-bottom=".5rem dotted #dbc3c0">
  <column text-center>
    <img rounded d-block mb-3 img-fluid webp="photo" src="./img/user.jpg" alt="user of software"/>
    <span>
      <button class="UDB" btn btn-warning>I'm a user!</button>
      <span style="display:none;">You give developers something to do! Preorder [Art Deco JavaScript](art-deco-js) to learn easy professional JS coding to become a developer yourself.</span>
    </span>

  </column>
  <column text-center>
    <img rounded d-block mb-3 img-fluid webp="photo" src="./img/developer.jpg" alt="developer of software"/>
    <span>
      <button class="UDB" btn btn-success>I'm a developer!</button>
      <span style="display:none;">The internet is made by people like you. Why not try [Alibaba Cloud Hosting](alibaba) and receive a 1GB instance free for 12 months?</span>
    </span>
  </column>
</row>

<!-- Most of the build pipelines are based on Webpack, _Rollup_ and Babel. And to tell you the truth: Open Source vendor lock is even worse than corporate one, because those who run such popular Open Source projects don't accept any criticism as they think that because they are volunteers, you don't have any rights as a user. -->

<!-- <p border rounded p-2 text-right box-shadow="0 3px 11px 5px lightsteelblue">
  <img img-fluid webp="text" src="./img/free.png" alt="free software" />
  <br><span text-monospace>^ In Open Source, you owe your life and business to maintainers for using their "free" software. It's a disgrace what the scene has been turned into.</span>
</p> -->

<!-- You're now vendor locked, AND you can't ever express your dissatisfaction with something. And actually why do we have to use software like Babel and Webpack &mdash; because it's good, or because we had no choice?  -->

<!-- so that you can expect to be a VALUED and LOVED user, and not hostage to somebody's technology. -->

<!-- because it's popular Open Source developers of those projects who now think they're the rules of the world with all that popularity hitting their heads, while you're not allowed to raise any complaints about their software, because they're apparently volunteers providing software to you for free. -->

<!-- It's true that Webpack as a build tool was needed during the last 5 years. It has got nice features like code splitting. But the room for dev utils that take advantage of present-day opportunities is being filled by more nimble software.  -->

Idio is a professional web server which has been compiled with Closure, and has only 2 dependencies. It consists of ES6-rewritten Koa with a collection of middleware, but it also allows to develop JavaScript for the browser. To enable web development process, it ships with our in-house *Front End* middleware &mdash; one of the modules-era nimble tools that does the following:

### 1. You specify the directory with your frontend code, e.g., `frontend`.

For example, you can have the following source in ``frontend/index.js``:

```js
import { dep } from 'my-dep'
import local from './local'

const el = document.querySelector('#id')
dep(el) // execute dependency
local(el) // execute local
```

When the browser requests this JS module via a script tag, `<script type="module" src="frontend"></script>`, *FrontEnd* will intersect the request, and lookup `my-dep` in your ``node_modules``, to find its _package.json_. From there, the *module* field will be read, and the served file will actually contain absolute paths required by the browser. Local dependencies can also be served, which would be impossible under normal circumstances when the extension (`.js`) is not present, but the middleware can handle that.

```js
import { dep } from '/node_modules/my-dep/src/index.js'
import local from './local'

const el = document.querySelector('#id')
dep(el) // execute dependency
local(el) // execute local
```

Now the browser can import the dependency natively. The middleware will return any JS file under the ``/node_module`` path, enabling direct dependency serving, without having to wrap anything in vendor modular system. This simple step drastically reduces the complexity of the tool-chain, as it's the browser that's doing most of the work from this point onwards. On-the-fly modifications of paths are made with the simplest RegEx that picks up `import` statements.

### 2. You write JSX code in your frontend.

JSX is positively THE BEST templating syntax for web development, and there's no doubt about that. Although it was initially developed by React, its roots actually go much deeper than that, as MXML (Flash applications) used to have similar structure.

<p>
  <img img-fluid webp="text" src="./img/binding.jpg" alt="flex bindings" />
  <br><span text-monospace> &copy; [Elad Elrom, Adobe](https://www.adobe.com/devnet/flex/articles/databinding_pitfalls.html) 2010</span>
</p>

JSX is a revival of MXML and an essential part of programming of the web. There's an interesting alternative to JSX called `lit-html` but it makes no sense why I should use template literals when writing tags. It's simply a hack to eliminate JSX transpilation, but it's not a replacement for JSX, which is the daddy of modern web computing.

<highlightjs src="./example/App.mjs"/>

An example of using lit html is the following:

<highlightjs src="./example/lit.mjs"/>

<p><span text-monospace>&copy; F1LT3R 2020, [`hybrids-dynamic-load`](https://github.com/F1LT3R/hybrids-dynamic-load).</span></p>

The advantage of this over JSX is that it doesn't require transpilation and can be run natively within a browser. The disadvantage is that there's no syntax highlighting (unless you use a plugin) and it's not as fluent as JSX that doesn't require calling `html` function to start a template block.

You might be thinking that to transpile JSX you need Babel, but the fact is that you don't. You don't need to build ASTs and you don't need to install additional 250 dependencies that come with Babel, another "established" standard of coding. *FrontEnd* uses a [JSX transpiler](https://github.com/a-la/jsx) powered by regular expressions. It includes a hack to find where the initial tag (``<``) is opening by evaluating the jsx file using the `vm` module of Node.JS. The tag is detected by listening to an error:

```jsx
/Users/zavr/a-la/jsx/test/fixture/Component.jsx:2
  <div className={className}>
  ^

SyntaxError: Unexpected token <
```

This evaluation is needed to prevent false positives, e.g., `if (a<example && b)`. After detecting the location of the angle bracket, we are able to parse text, until the closing tag is found, unless it was self-closing. Properties are also extracted using regular expressions on strings. Now look, you can think that it's very simplistic, but this stuff works and works really well. It supports comments and pretty much everything you want from JSX, except that you can't use `>` in properties, e.g.,

<highlightjs src="./example/Component.mjs" lang="jsx"/>

But methods like that simply need to be taken out of the tag scope. You're probably not going to replace Webpack with Idio at your corporate insurer job, but if you're working for fun projects, there's no reason why you can't be using this. Except for that there's no source maps, which will be added later on this year, but because the code produced looks absolutely natural, it's easy to debug it anyway (unless you've got the super-power setup where your VS Code debugger hooks up to a running Chrome RDP process).

```js
// JSX - compiled code
import { render, Component } from 'preact'

class App extends Component {
  constructor() {
    super()
    this.state = { name: 'world' }
  }
  render({ message }) {
    return (h('div',{},
      `Hello, `,h('span',{},this.state.name),
      h('p',{},
        message,
      ),
    ))
  }
}

render(h(App,{message:"Idio"}), document.querySelector('.app'))
```

I've created many [widgets](https://akashic.page), [front-end apps](https://github.com/art-deco/file-upload.artdeco.app) and back-end servers with SSR powered by this transpiler. There hasn't been any problems. Maybe it will throw errors on some very advanced edge use cases (never happened for me, although your usage might be something I've never tested), but simplifying code will always help. Its simplicity is the key.

<row d-flex align-items-center>
  <column lg-6 xl-7 mb-3>
    <img rounded img-fluid src="./img/control.jpg" webp="photo" alt="control photo with birds" />
  </column>
  <column lg-6 xl-5>

    As an indie web developer, I was looking to fulfil the need to create JS applications for the web without anything getting in the way. I wanted to breath freely when working on each new project, and not be brought down by the anxiety that filled me up when my ``node_modules`` were being taken over and I lost all control. There's no happier place than to be able to direct the development process, saying, "I'm the boss here, not you, dependencies!".
  </column>
</row>

The *FrontEnd* solution might not be approved in corporate &mdash; which only confirms the fact they've been locked into their "Open Source" software, but for JS enthusiasts and hackers, it's perfect. I'm not offering you an alternative that you'll be stuck with: you can see that developing front-end is really easy in 2020, as all you need is to serve JavaScript modules with a few on-the-fly modifications. I've not invented a new system, I've only patched up those things that were missing:

1. rename imported package names into paths: ``'dep'`` -> `'/node_modules/dep/src/module.js'`;
1. serve packages and other JS files even without extensions (`'./lib'`);
1. transpile JSX on the fly via MVP transpiler;
1. [read below] implement hot reload for ES6 exports.

<!-- After being liberated from the shackles of dependencies, I could finally focus on writing source code to build more software products for my company. But most of all, I've gained independence. -->

<div mb-3>
  <animation
    src="./img/frontend.png" alt="frontend middleware" width="623" height="256"
    path="../../flash/animate/frontend.json" noscript="./img/frontend.gif" />
</div>

These 4 things enable clean development environment with minimum technical debt. With browsers supporting modules, we can leave build tools for building, but develop code natively. All features that we might want are implemented by Chrome &mdash; happy days. It's true that we'll also need to combine our frontend code into a bundle, but we'll discuss the build step at the end. For now, let's have a look at hot reload, the final requirement for the front-end and its simplest form of implementation.

<section-break />