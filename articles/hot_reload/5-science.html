##! Scientific Approach

Making software isn't about programming. If you think that you can just install a bunch of dependencies, and add a bit of code, you're making a script. The purpose of going to University to learn Computer Science, is to get trained as a scientist which isn't about programming at all. If you want to learn frameworks, don't bother with a degree. Making software and professional Software Engineering is pure science. The job of a scientist is a process:

- Understand the problem at hand, do the research.
- Come up with a hypothesis, i.e. how you're going to solve the problem, what results do you expect.
- Prepare and conduct your experiments to get empirical data.
- Evaluate the hypothesis against the results. If they don't match, report it to understand why and start over.

I'm going to show how I take scientific approach to solving problems. If Computer *Science* is a theoretical framework for your life (not just computation theory), Software *Engineering* is a practical application of this framework. Each step in the former corresponds to a step in the latter so let me draw parallels.

<p>
  <img rounded webp="photo" img-fluid src="./img/science.jpg" alt="software engineering is science" />
</p>

Traditional Software Engineering makes use of the waterfall model:

1. *Requirements study*: talk to the client and stakeholders to draw and agree requirements, to limit the scope of the system.
1. *Designs*: produce designs of the system, such as UML, use cases, and come up with a few early prototypes. This will guide your development process and help to communicate with the client.
1. *Implementation*: get on with building the system, spawning dev/staging environments and deploying code as it comes.
1. *Testing*: today we usually write tests during implementation, and even tend to utilise TDD. But every developer will know that tests can be sloppy when we were in the flow of programming and didn't bother to add tests. At this stage, we can pull up our test coverage so that our software product is of acceptable quality. More integration and manual testing is also done here.
1. *Evaluation*: deploy staging and let stakeholders use it. Speak to them, to see if the built solution matches the agreed requirements.
1. *Delivery & Maintenance*: software is deployed to production and handed over to the client. Most often than not, the same development company will maintain it. Plan for next versions from the points raised in evaluation.

Today, we mostly hear about "agile" and "iterative process", but traditional approach is more conservative and allows to prevent scope creeping. We focus on the RESULT that we want to achieve with our system &mdash; whereas within this main process, we can apply agile for implementation.

<!-- There's absolutely no respect left online for proper scientists. Probably only around 1% of people who call themselves Software Engineers, even having a Computer Science degree, take scientific approach. Others think they're here to code, and programming is the most important thing. Software engineering is so much more than that. You need to understand your problem, draw requirements, create designs, implement them, test functionally and against business goals, and maintain. Our culture has degenerated completely and people don't even know what culture is: they think they make a popular package, so they must be really good.  -->

### The problem

Understanding the problem